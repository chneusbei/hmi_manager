Index: src/main/java/com/plc/hmi/service/plcService/Plc4xCurveStatusService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/com/plc/hmi/service/plcService/Plc4xCurveStatusService.java	(revision b19a144bc605d376a33eac801323ba4f8edbdae9)
+++ src/main/java/com/plc/hmi/service/plcService/Plc4xCurveStatusService.java	(date 1622799068727)
@@ -45,7 +45,7 @@
     public CurveStatusEntity getCurveStatus(List<PlcEntity> entityList) {
         CurveStatusEntity curveStatusEntity = new CurveStatusEntity();
 
-        if (!CollectionUtils.isEmpty(entityList)) {
+        if (CollectionUtils.isEmpty(entityList)) {
             return curveStatusEntity;
         }
         for (PlcEntity plcEntity : entityList) {
Index: src/main/java/com/plc/hmi/service/plcService/Plc4xCurveDataService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/com/plc/hmi/service/plcService/Plc4xCurveDataService.java	(revision b19a144bc605d376a33eac801323ba4f8edbdae9)
+++ src/main/java/com/plc/hmi/service/plcService/Plc4xCurveDataService.java	(date 1622814054992)
@@ -41,7 +41,7 @@
     public static Map<Long, List<PressureCurveEntity>> curveMap2 = new HashMap<Long, List<PressureCurveEntity>>();
 //    public static PressureCurveEntity currentCurve2 = new PressureCurveEntity();
     public static Long productNo=1L;
-    public static Long productNo2=0L;
+    public static Long productNo2=1L;
     static int  preCurveLength1 =0;
     static int  preCurveLength2 =0;
 //    private static Long startTime= 0L;
@@ -143,7 +143,7 @@
                 paraMap.put("motion_state1", "99");
                 this.setDatas(HmiConstants.PLC_TAG_GROUP.CURVE_DATA_UPDATE.getCode(), paraMap);
                 //需要将除当前当前零件外的其他信息全部入库并从map中去除。
-                curve2DB(curveMap);
+                curve2DB(1, curveMap);
             }
             preCurveLength1 = curveStatusEntity.getDataLength1();
         }
@@ -160,7 +160,7 @@
                     paraMap.put("motion_state2", "99");
                     this.setDatas(HmiConstants.PLC_TAG_GROUP.CURVE_DATA_UPDATE.getCode(), paraMap);
                     //双曲线入库
-                    curve2DB(curveMap2);
+                    curve2DB(2, curveMap2);
                 }
                 preCurveLength2 = curveStatusEntity.getDataLength2();
             }
@@ -171,7 +171,7 @@
      * 数据入库
      * @param map
      */
-    private  void curve2DB(Map<Long, List<PressureCurveEntity>> map) {
+    private  void curve2DB(int pressHeadNo, Map<Long, List<PressureCurveEntity>> map) {
         if (!map.isEmpty()) {
           /*  try {
                 //睡眠1秒，让页面有足够时间做paint
@@ -182,18 +182,18 @@
 //                System.out.println("set curve data to batch insert thread*************************");
 //                pressureCurveService.curve2queue(curveMap.get(productNo));
 //                Iterator<Long> it=curveMap.keySet().iterator();
-            ArrayList<Boolean> isOkList = null;
+            boolean isOk = true;
             List<PressureCurveEntity> entityList = null;
             for(Long recordId : map.keySet()){
                 entityList = map.get(recordId);
 //                if(!CollectionUtils.isEmpty(entityList) && entityList.size() > 30) {
                 if(!CollectionUtils.isEmpty(entityList)) {
-                   isOkList = pressureCurveService.batchInsert(entityList);
+                    isOk = pressureCurveService.batchInsert(String.valueOf(pressHeadNo), entityList);
                 }
             }
 
             // 数据入库后，修改PLC的OK/NOK/压装完成  三个变量
-            setFlagAfterPressure(isOkList);
+            setFlagAfterPressure(pressHeadNo, isOk);
             map.clear();
         }
     }
@@ -219,7 +219,7 @@
         } else {
             if (CollectionUtils.isEmpty(curveMap2)) {
                 //如果容器是空的， 说明是新曲线， 曲线id 递增。
-                productNo ++;
+                productNo2 ++;
             }
         }
 
@@ -240,7 +240,11 @@
             curveEntity.setSolidLine(true);
             curveEntity.setErrant(false);
             curveEntity.setPressureHeadNo(pressHeadNo);
-            curveEntity.setRecordNo(productNo);
+            if(pressHeadNo ==1 ) {
+                curveEntity.setRecordNo(productNo);
+            } else {
+                curveEntity.setRecordNo(productNo2);
+            }
             if (null == curveEntity.getCurveRecording()) {
                 curveEntity.setCurveRecording(false);
             }
@@ -248,12 +252,20 @@
             curveEntityList.add(curveEntity);
         }
 
-
-        if (CollectionUtils.isEmpty(curveMap.get(productNo))) {
-            curveMap.put(productNo, curveEntityList);
-        } else {
-            curveMap.get(productNo).addAll(curveEntityList);
+        if(pressHeadNo ==1 ) {
+            if (CollectionUtils.isEmpty(curveMap.get(productNo))) {
+                curveMap.put(productNo, curveEntityList);
+            } else {
+                curveMap.get(productNo).addAll(curveEntityList);
+            }
+        } else {
+            if (CollectionUtils.isEmpty(curveMap2.get(productNo))) {
+                curveMap2.put(productNo, curveEntityList);
+            } else {
+                curveMap2.get(productNo).addAll(curveEntityList);
+            }
         }
+
         return curveEntityList;
     }
 
@@ -509,33 +521,31 @@
     /**
      * 压装结束后，设置曲线状态，OK /NOK/压装完成
      */
-    public  void setFlagAfterPressure(ArrayList<Boolean> isOkList) {
+    public  void setFlagAfterPressure(int pressHeadNo, boolean isOk) {
         Map<String, String> paraMap = new HashMap<>();
-        if(CollectionUtils.isEmpty(isOkList)) {
-            return;
-        }
-        boolean  isOk = isOkList.get(0);
-
+        System.out.println("*************发送状态位时第"+pressHeadNo+"个压头的压装结果"+isOk);
         if(isOk) {
-            paraMap.put("ok", "true");
-            paraMap.put("nok", "false");
+//            System.out.println("*************发送状态位时第一个压头的压装结果"+isOk);
+            if(pressHeadNo ==1) {
+                paraMap.put("ok", "true");
+                paraMap.put("nok", "false");
+            } else {
+                paraMap.put("ok2", "true");
+                paraMap.put("nok2", "false");
+            }
         } else {
-            paraMap.put("ok", "false");
-            paraMap.put("nok", "true");
-        }
-
-        paraMap.put("finish", "true");
-
-        if(isOkList.size() == 2) {
-            boolean isOK2 = isOkList.get(1);
-            System.out.println("*************发送状态位时第二个压头的压装结果"+isOK2);
-            if(isOK2) {
-                paraMap.put("ok2", "true");
-                paraMap.put("nok2", "false");
+            if(pressHeadNo ==1) {
+                paraMap.put("ok", "false");
+                paraMap.put("nok", "true");
             } else {
                 paraMap.put("ok2", "false");
                 paraMap.put("nok2", "true");
             }
+        }
+
+        if(pressHeadNo ==1) {
+            paraMap.put("finish", "true");
+        } else {
             paraMap.put("finish2", "true");
         }
 
Index: src/main/java/com/plc/hmi/S7Connector/service/Plc4xConnectorService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/com/plc/hmi/S7Connector/service/Plc4xConnectorService.java	(revision b19a144bc605d376a33eac801323ba4f8edbdae9)
+++ src/main/java/com/plc/hmi/S7Connector/service/Plc4xConnectorService.java	(date 1622806552650)
@@ -119,7 +119,9 @@
         PlcReadRequest readRequest = builder.build();
         PlcReadResponse response =null;
         try {
+            System.out.println("============================begin querey");
             response = readRequest.execute().get();
+            System.out.println("============================  querey end ");
         } catch (InterruptedException e) {
             logger.error("execute readRequeset error." + e.getStackTrace());
             e.printStackTrace();
Index: src/main/java/com/plc/hmi/service/PressureCurveService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/com/plc/hmi/service/PressureCurveService.java	(revision b19a144bc605d376a33eac801323ba4f8edbdae9)
+++ src/main/java/com/plc/hmi/service/PressureCurveService.java	(date 1622818587119)
@@ -77,46 +77,19 @@
      * 批量入库
      * @param entityList
      */
-    public ArrayList<Boolean> batchInsert(List<PressureCurveEntity> entityList) {
+    public boolean  batchInsert(String pressHeadNo, List<PressureCurveEntity> entityList) {
         //需要对应插入一条数据到pressure_data, 同时建立pressure_data和pressure_curve的关联关系
         /**
          *  1 插入pressure_data
          *  如果是双压头， 需要将数据拆分到两个list中
          */
-        ArrayList<Boolean> isOkList = new ArrayList<Boolean>();
-        if(propertyService.isDubblePress()) {
-            List<PressureCurveEntity> pressureHeadList1 = new ArrayList();
-            List<PressureCurveEntity> pressureHeadList2 = new ArrayList();
-            for(PressureCurveEntity entity : entityList) {
-                if(entity.getPressureHeadNo() == 1) {
-                    pressureHeadList1.add(entity);
-                } else if(entity.getPressureHeadNo() == 2){
-                    pressureHeadList2.add(entity);
-                }
+        boolean isOk = InsertPressureDate(entityList, pressHeadNo);
 
-            }
-            boolean isOk1 = true;
-            if(!CollectionUtils.isEmpty(pressureHeadList1)) {
-                isOk1 = InsertPressureDate(pressureHeadList1, "1");
-                System.out.println(">>>>>>>>>>>>>>>>第一个压头的压装结果"+isOk1);
-            }
-
-            boolean isOk2 = true;
-            if(!CollectionUtils.isEmpty(pressureHeadList2)) {
-                isOk2 = InsertPressureDate(pressureHeadList2, "2");
-                System.out.println(">>>>>>>>>>>>>>>>第二个压头的压装结果"+isOk2);
-            }
-            isOkList.add(isOk1);
-            isOkList.add(isOk2);
-        } else {
-            boolean isOk = InsertPressureDate(entityList, "1");
-            isOkList.add(isOk);
-        }
         /**
          * 1 插入pressure_curve
          */
         pressureCurveDao.batchInsert(entityList);
-        return isOkList;
+        return isOk;
     }
 
     private boolean InsertPressureDate(List<PressureCurveEntity> entityList, String pressHeadNo) {
@@ -152,15 +125,14 @@
             PressureProgramEntity pressureProgramEntity = programService.getErrandData(programCode);
             hasErrand = setErrandResultList(pressureProgramEntity, errandResultList);
 
-            int i = 0;
+           /* int i = 0;
             for (PressureCurveEntity curveEntity : entityList) {
                 i++;
                 curveEntity.setRecordId(recordId);
                 MaxPressure = MaxPressure.getPressForce().compareTo(curveEntity.getPressForce()) < 0 ? curveEntity : MaxPressure;
                 //判断公差窗口
-
                 setCurveResultStatus(errandResultList, curveEntity, i == entityList.size() ? true : false);
-            }
+            }*/
         }
         PressureDataEntity pressureDataEntity = new PressureDataEntity();
         pressureDataEntity.setProductId(productId);
@@ -171,7 +143,8 @@
             pressureDataEntity.setPressResult("0");//压力超限 1成功 0 失败
         } else {
             if(showErrand && hasErrand) {
-                isOk = isCurveSuccess(errandResultList);
+//                isOk = isCurveSuccess(errandResultList);
+                isOk = setCurveResult(errandResultList, entityList);
             } else {
                 isOk=true;
             }
@@ -191,6 +164,360 @@
     }
 
 
+    /***
+     * 根据公差窗口确定曲线是否压装是成功的
+     */
+    private boolean  setCurveResult(List<ErrandResultEntity> errandResultList,  List<PressureCurveEntity> entityList) {
+        if(errandResultList.size()==0) {
+            return true;
+        }
+        boolean isOk = true;
+        for(ErrandResultEntity errandResultEntity : errandResultList) {
+            boolean thisResult = setCurveResult(errandResultEntity, entityList);
+            if(!thisResult) {
+                isOk = false;
+                break;
+            }
+        }
+        return isOk;
+    }
+
+    private boolean setCurveResult(ErrandResultEntity errandResultEntity, List<PressureCurveEntity> entityList) {
+        //获取和公差窗口交叉区间的曲线点及其实结束序号
+        List<PressureCurveEntity> subEntityList = new ArrayList<PressureCurveEntity>();
+        int index = 0;
+        int start = 0;
+        int end = 0;
+        BigDecimal minPosition = BigDecimal.ZERO;
+        BigDecimal maxPosition = BigDecimal.ZERO;
+        BigDecimal minPress = BigDecimal.ZERO;
+        BigDecimal maxPress = BigDecimal.ZERO;
+        BigDecimal subMinPosition = BigDecimal.ZERO;
+        BigDecimal subMaxPosition = BigDecimal.ZERO;
+        BigDecimal subMinPress = BigDecimal.ZERO;
+        BigDecimal subMaxPress = BigDecimal.ZERO;
+        for(PressureCurveEntity pressureCurveEntity: entityList) {
+
+            if(pressureCurveEntity.getPosition().compareTo(errandResultEntity.getPositionMin()) >= 0
+                && pressureCurveEntity.getPosition().compareTo(errandResultEntity.getPositionMax()) <= 0) {
+                if(start == 0) {
+                    start = index;
+                    subMinPosition = pressureCurveEntity.getPosition();
+                    subMinPress = pressureCurveEntity.getPressForce();
+                }
+                subEntityList.add(pressureCurveEntity);
+                end = index;
+                subMinPosition = subMinPosition.compareTo( pressureCurveEntity.getPosition()) < 0 ? subMinPosition  : pressureCurveEntity.getPosition();
+                subMaxPosition = subMaxPosition.compareTo( pressureCurveEntity.getPosition()) > 0 ? subMaxPosition  : pressureCurveEntity.getPosition();
+                subMinPress = subMinPress.compareTo( pressureCurveEntity.getPressForce()) < 0 ? subMinPress  : pressureCurveEntity.getPressForce();
+                subMaxPress = subMaxPress.compareTo( pressureCurveEntity.getPressForce()) > 0 ? subMaxPress  : pressureCurveEntity.getPressForce();
+            }
+
+            if(index == 0) {
+                minPosition = pressureCurveEntity.getPosition();
+                minPress = pressureCurveEntity.getPressForce();
+            }
+            minPosition = minPosition.compareTo( pressureCurveEntity.getPosition()) < 0 ? minPosition  : pressureCurveEntity.getPosition();
+            maxPosition = maxPosition.compareTo( pressureCurveEntity.getPosition()) > 0 ? maxPosition  : pressureCurveEntity.getPosition();
+            minPress = minPress.compareTo( pressureCurveEntity.getPressForce()) < 0 ? minPress  : pressureCurveEntity.getPressForce();
+            maxPress = maxPress.compareTo( pressureCurveEntity.getPressForce()) > 0 ? maxPress  : pressureCurveEntity.getPressForce();
+            index++;
+        }
+
+
+        if(errandResultEntity.getErrandType() == 0) {
+
+            //最大位移窗口
+            //成功条件：1.最大位移大于positionMin  2.最大位移小于positionMax
+            //判断是否达到最小位移点
+            if (subEntityList.size() > 0 &&  maxPosition.compareTo(errandResultEntity.getPositionMax()) < 0) {
+                return true;
+            } else {
+                return false;
+            }
+
+        } else if(errandResultEntity.getErrandType() == 1) {
+                //最大压力窗口
+                //成功条件：1.最大压力大于等于pressMin  2.最大压力小于等于positionMax
+
+                //判断是否达到最小压力点
+//                if(!errandResultEntity.isMinPressSucess()) {
+                if(curveEntity.getPressForce().compareTo(errandResultEntity.getPressMin()) >=0) {
+                    errandResultEntity.setMinPressFlag(true);
+                }
+//                }
+                //判断是否超过最大压力点
+//                if(errandResultEntity.isMaxPressSucess()) {
+                if(curveEntity.getPressForce().compareTo(errandResultEntity.getPressMax()) >0) {
+                    errandResultEntity.setMaxPressSuccess(false);
+                    break;
+                }
+//                }
+
+        } else if(errandResultEntity.getErrandType() == 2) {
+            //配合窗口
+                /*
+                  测量曲线必须完全通过力窗口，不能碰到窗口上下边
+                  1.未达到对应的位置失败
+                  2.未穿越最大位移失败
+                  3.穿越期间如果碰到上下压力位置，失败
+                 */
+            //判断是否达到最小位移点
+//                if(!errandResultEntity.isMinPositonSucess()) {
+            if (curveEntity.getPosition().compareTo(errandResultEntity.getPositionMin()) >= 0) {
+                errandResultEntity.setMinPositionFlag(true);
+            }
+//                }
+
+            //判断是否达到最大位移点
+//                if(!errandResultEntity.isMaxPositonSucess()) {
+            if (curveEntity.getPosition().compareTo(errandResultEntity.getPositionMax()) > 0) {
+                errandResultEntity.setMaxPositionFlag(true);
+            }
+//                }
+
+            //位置在最小位移和最大位移中间时才做判断
+            if (curveEntity.getPosition().compareTo(errandResultEntity.getPositionMin()) >= 0
+                    && curveEntity.getPosition().compareTo(errandResultEntity.getPositionMax()) <= 0
+                //&& errandResultEntity.isMinPressSucess() && errandResultEntity.isMaxPressSucess()
+            ) {
+                //判断是否大于最小压力
+                if (curveEntity.getPressForce().compareTo(errandResultEntity.getPressMin()) < 0) {
+                    errandResultEntity.setMinPressSuccess(false);
+                    break;
+                }
+
+                //判断是否小于最大压力
+                if (curveEntity.getPressForce().compareTo(errandResultEntity.getPressMax()) > 0) {
+                    errandResultEntity.setMaxPressSuccess(false);
+                    break;
+                }
+            }
+        } else if(errandResultEntity.getErrandType() == 3) {
+                //右-下限制窗口
+                //穿过右边实线场景，存在BUG，会判定成功
+                /*
+                  曲线必须在窗口下限以上通过窗口，不能碰到窗口右边界。在窗口中至少找到一个测量点
+                  1.未达到最小位移 失败
+                  2.大于最小位移， 小于最大位移时，必须大于最小压力
+                  3.在窗口期间必须有大于最大压力的值
+                  4.必须有小于最小位移的点
+                  5.如果达到最大位移点， 压力要大于最大压力
+                 */
+                //判断是否有小于最小位移点
+//                if(!errandResultEntity.isHasPointBeforeMinPosition()) {
+                if(curveEntity.getPosition().compareTo(errandResultEntity.getPositionMin()) < 0) {
+                    errandResultEntity.setMinPositionFlag(true);
+                }
+//                }
+
+
+                //位置在最小位移和最大位移中间时才做判断
+                if(curveEntity.getPosition().compareTo(errandResultEntity.getPositionMin()) >=0
+                        && curveEntity.getPosition().compareTo(errandResultEntity.getPositionMax()) <=0
+                    // && errandResultEntity.isMinPressSucess()
+                ) {
+                    //判断是否大于最大压力
+                    /*
+                    if(!errandResultEntity.isMaxPressSucess()) {
+                        if(curveEntity.getPressForce().compareTo(errandResultEntity.getPressMax()) >= 0) {
+                            errandResultEntity.setMaxPressSucess(true);
+                        }
+                    }
+                    */
+                    //判断是否大于最小压力
+                    if(curveEntity.getPressForce().compareTo(errandResultEntity.getPressMin()) <= 0) {
+                        errandResultEntity.setMinPressSuccess(false);
+                        break;
+                    }
+
+                }
+
+                break;
+        } else if(errandResultEntity.getErrandType() == 4) {
+                //穿越窗口
+                //不支持， 默认全是成功
+                break;
+        } else if(errandResultEntity.getErrandType() == 5) {
+                //峰值窗口
+                // 只测试了NOK场景
+                /**
+                 * 测量曲线必须在窗口上边界以下通过，不能碰到窗口左边界和右边界。曲线必须在
+                 *  窗口外部开始和结束。在窗口里至少找到一个测量点。
+                 *  1.必须存在最小位移之前的点
+                 *  2.必须存在最大位位移之后的点
+                 *  3.最大最小位移之间的点， 必须存在大于最小压力的点
+                 *  4.最大最小位移之间的点， 不能存在大于最大压力的点
+                 */
+                /*
+                //判断是否有小于最小位移点
+                if(!errandResultEntity.isHasPointBeforeMinPosition()) {
+                    if(curveEntity.getPosition().compareTo(errandResultEntity.getPositionMin()) < 0) {
+                        errandResultEntity.setHasPointBeforeMinPosition(true);
+                    }
+                }
+
+                //判断是否有大于最大位移点
+                if(!errandResultEntity.isHasPointAfterMaxPosition()) {
+                    if(curveEntity.getPosition().compareTo(errandResultEntity.getPositionMax()) > 0) {
+                        errandResultEntity.setHasPointAfterMaxPosition(true);
+                    }
+                }
+                */
+                //位置在最小位移和最大位移中间时才做判断
+                if(curveEntity.getPosition().compareTo(errandResultEntity.getPositionMin()) >=0
+                        && curveEntity.getPosition().compareTo(errandResultEntity.getPositionMax()) <=0
+                    // && errandResultEntity.isMaxPressSucess()
+                ) {
+                    if(curveEntity.getPosition().compareTo(errandResultEntity.getPositionMin()) == 0
+                            || curveEntity.getPosition().compareTo(errandResultEntity.getPositionMax()) ==0) {
+                        //最小位移点时 //最大位移点时
+                        if(curveEntity.getPressForce().compareTo(errandResultEntity.getPressMin()) > 0){
+                            errandResultEntity.setMaxPressSuccess(false);
+                            break;
+                        }
+                    }
+
+                    //判断是否大于最大压力
+                    // if(errandResultEntity.isMaxPressSucess()) {
+                    if(curveEntity.getPressForce().compareTo(errandResultEntity.getPressMax()) >= 0) {
+                        errandResultEntity.setMaxPressSuccess(false);
+                        break;
+                    }
+                    // }
+
+                    //判断是否大于最小压力
+                    if(curveEntity.getPressForce().compareTo(errandResultEntity.getPressMin()) > 0) {
+                        errandResultEntity.setMinPressFlag(true);
+                    }
+
+                }
+
+        } else if(errandResultEntity.getErrandType() == 6) {
+                //左-上限制窗口
+                //穿过左侧实现场景，存在BUG
+                /*
+                 曲线必须在窗口上边界下面通过，不能碰到窗口左边界。曲线可在窗口内开始或结
+                束。在窗口中必须至少找到一个测量点
+                1.必须到达最小位置和最大位置之间
+                2.不能超过最大压力点
+                 */
+                //位置在最小位移和最大位移中间时才做判断
+                if(curveEntity.getPosition().compareTo(errandResultEntity.getPositionMin()) >=0
+                        && curveEntity.getPosition().compareTo(errandResultEntity.getPositionMax()) <=0
+//                        && errandResultEntity.isMaxPressSucess()
+                ) {
+                    //设置进入箱体成功
+//                    if(!errandResultEntity.isMinPositonSucess()) {
+                    if(curveEntity.getPressForce().compareTo(errandResultEntity.getPressMin()) > 0) {
+                        errandResultEntity.setMinPressFlag(true);
+                    }
+
+//                    }
+                    //判断是否大于最大压力
+//                    if(errandResultEntity.isMaxPressSucess()) {
+                    if(curveEntity.getPressForce().compareTo(errandResultEntity.getPressMax()) >= 0) {
+                        errandResultEntity.setMaxPressSuccess(false);
+                        break;
+                    }
+//                    }
+                }
+
+        } else if(errandResultEntity.getErrandType() == 7) {
+                //右-上限制窗口
+                //不支持， 默认全是成功
+
+        } else if(errandResultEntity.getErrandType() == 8) {
+                //顶部结束窗口
+                /*
+                曲线必须在窗口内结束，曲线必须在窗口上边界下通过，并且不能碰到窗口左右边
+                界。曲线必须在窗口外部开始，至少一个测量点必须在窗口内找到
+                1.需要有在箱体之外的点， 位置小于最小位置， 或者位置在最小最大位移之间，但是小于等于最小压力
+                2.最后一个点一定要在箱体里。只判断最有一个点
+                 */
+                //1 判断是否有箱体外面的点, 条件：大于等于最小位移，小于最大位移，且小于小压力
+                if(curveEntity.getPosition().compareTo(errandResultEntity.getPositionMin()) >=0
+                        && curveEntity.getPosition().compareTo(errandResultEntity.getPositionMax()) < 0
+                    //&& curveEntity.getPressForce().compareTo(errandResultEntity.getPressMin()) < 0
+                ) {
+                    if(curveEntity.getPressForce().compareTo(errandResultEntity.getPressMin()) < 0) {
+                        errandResultEntity.setMinPositionFlag(true);
+                    }
+                    if(curveEntity.getPressForce().compareTo(errandResultEntity.getPressMax()) > 0) {
+                        errandResultEntity.setMaxPressSuccess(false);
+                        break;
+                    }
+                }
+                //2 判断最后一个点是否符合要求, 条件 ：大于等于最小位移、小于等于最大位移、大于等于最小压力，小于等于最大压力
+                // 最后一个点不是最高点，是0点， 所有最后一个点的判断都不对
+                if(isLastOne) {
+                    if (curveEntity.getPosition().compareTo(errandResultEntity.getPositionMin()) <= 0
+                            || curveEntity.getPosition().compareTo(errandResultEntity.getPositionMax()) >= 0
+                            || curveEntity.getPressForce().compareTo(errandResultEntity.getPressMin()) <= 0
+                            || curveEntity.getPressForce().compareTo(errandResultEntity.getPressMax()) >= 0
+                    ) {
+                        errandResultEntity.setMaxPressSuccess(false);
+                        break;
+                    }
+                }
+
+        } else if(errandResultEntity.getErrandType() == 9) {
+                //右侧结束窗口
+                // 最后一个点不是最高点，是0点， 所有最后一个点的判断都不对
+                /*
+                曲线必须在窗口上下边界通过，且不碰到窗口右边界。在窗口里必须找到一个测量点，曲线必须在窗口内结束
+                1.不能触碰上下压力边界
+                2.在箱体内部结束
+                 */
+                //1 在最大最小位移点中间时， 必须小于最大压力， 大于最小压力
+                if(//errandResultEntity.isMinPressSucess()  &&
+                        curveEntity.getPosition().compareTo(errandResultEntity.getPositionMin()) >=0
+                                && curveEntity.getPosition().compareTo(errandResultEntity.getPositionMax()) < 0
+                ) {
+                    if(!errandResultEntity.isMinPositionFlag()) {
+                        errandResultEntity.setMinPositionFlag(true);
+                    }
+                    if(curveEntity.getPressForce().compareTo(errandResultEntity.getPressMin()) <= 0
+                            || curveEntity.getPressForce().compareTo(errandResultEntity.getPressMax()) >= 0) {
+                        errandResultEntity.setMinPressSuccess(false);
+//                        System.out.println("左进右不出判断失败 position="+curveEntity.getPosition()
+//                                +"， PositionMin=" + errandResultEntity.getPositionMin()
+//                                +"， PositionMax=" + errandResultEntity.getPositionMax()
+//                                +"， PressForce=" + curveEntity.getPressForce()
+//                                +"， PressMin=" + errandResultEntity.getPressMin()
+//                                +"， PressMax=" + errandResultEntity.getPressMax()
+//                        );
+                        break;
+                    }
+                }
+
+
+                //2 判断最后一个点是否符合要求, 条件 ：大于等于最小位移、小于等于最大位移、大于等于最小压力，小于等于最大压力
+                /*
+                if(isLastOne) {
+                    if (curveEntity.getPosition().compareTo(errandResultEntity.getPositionMin()) <= 0
+                            || curveEntity.getPosition().compareTo(errandResultEntity.getPositionMax()) >= 0
+                           || curveEntity.getPressForce().compareTo(errandResultEntity.getPressMin()) <= 0
+                                || curveEntity.getPressForce().compareTo(errandResultEntity.getPressMax()) >= 0) {
+                            errandResultEntity.setMaxPressSucess(false);
+                            break;
+                    }
+                }
+                 */
+        } else if(errandResultEntity.getErrandType() == 10) {
+                //平均值窗口
+                //不支持， 默认全是成功
+
+        } else if(errandResultEntity.getErrandType() == 11) {
+                //拐点窗口
+                //不支持， 默认全是成功
+
+
+        } else {
+            return true;
+        }
+
+    }
 
     /***
      * 根据公差窗口确定曲线是否压装是成功的
@@ -567,7 +894,7 @@
         }
 
         //设置公差窗口默认值
-        for(ErrandResultEntity entity : errandResltList) {
+       /* for(ErrandResultEntity entity : errandResltList) {
             if(0==entity.getErrandType()) {
                 //最大位移窗口
                 entity.setMinPositionFlag(false);
@@ -597,7 +924,7 @@
                 //右侧结束窗口
                 entity.setMinPositionFlag(false);
             }
-        }
+        }*/
         return hasErrand;
     }
 
@@ -761,7 +1088,7 @@
      * 自动批量入库
      */
     public void autoBatchInsert() {
-        System.out.println("批量插入操作。。。。。。。。。。。。。。。。。。。。。 sie = " + synCurveDeque.size());
+       /* System.out.println("批量插入操作。。。。。。。。。。。。。。。。。。。。。 sie = " + synCurveDeque.size());
         if(!synCurveDeque.isEmpty()) {
             List<PressureCurveEntity> entityList = new ArrayList<PressureCurveEntity>();
             while(!synCurveDeque.isEmpty()) {
@@ -771,8 +1098,6 @@
                     entityList.clear();
                 }
             }
-        }
+        }*/
     }
-
-
 }
Index: src/main/java/com/plc/hmi/service/plcService/Plc4xBaseService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/com/plc/hmi/service/plcService/Plc4xBaseService.java	(revision b19a144bc605d376a33eac801323ba4f8edbdae9)
+++ src/main/java/com/plc/hmi/service/plcService/Plc4xBaseService.java	(date 1622804617293)
@@ -93,13 +93,13 @@
             return;
         }
         List<TagsInfoEntity> tags = tagsInfoService.getTagsByGroup(tagGroup);
-        boolean isDubblePress = propertyService.isDubblePress();
+//        boolean isDubblePress = propertyService.isDubblePress();
         //当是曲线信息， 且双压头标识是开的，增加读取第二个压头的tagGroup
-        if(HmiConstants.PLC_TAG_GROUP.CURVE_DATA.getCode().equalsIgnoreCase(tagGroup)
+        /*if(HmiConstants.PLC_TAG_GROUP.CURVE_DATA.getCode().equalsIgnoreCase(tagGroup)
         && isDubblePress) {
             List<TagsInfoEntity> tags2 = tagsInfoService.getTagsByGroup(HmiConstants.PLC_TAG_GROUP.CURVE_DATA_2.getCode());
             tags.addAll(tags2);
-        }
+        }*/
         setQueryList(tags);
     }
 
